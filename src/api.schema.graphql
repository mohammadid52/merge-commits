enum Language {
  EN
  ES
  VT
  TR
  CZ
}

enum PersonStatus {
  ACTIVE
  SUSPENDED
  INACTIVE
  HOLD
}

enum Role {
  SUP
  ADM
  BLD
  FLW
  CRD
  TR
  ST
}

#Person - App users table.
type Person
  @model
  @key(fields: ["email", "authId"])
  @key(name: "byUserId", fields: ["id"], queryField: "userById")
  @key(name: "byRole", fields: ["role"], queryField: "usersByRole") {
  id: ID!
  authId: String!
  status: PersonStatus!
  email: String!
  role: Role!
  type: String
  firstName: String!
  preferredName: String
  lastName: String!
  externalId: String
  grade: String
  onBoardSurvey: Boolean
  offBoardSurvey: Boolean
  phone: String
  birthdate: AWSDate
  image: String
  language: Language!
  filters: [String]
  lastLoggedIn: AWSDateTime
  lastLoggedOut: AWSDateTime
  onDemand: Boolean
  sentiments: [String]
  passcode: String
  classes: [ClassStudent] @connection(keyName: "classByStudent", fields: ["email"])
  spotlightUser: Boolean
  spotlightDate: AWSDate
  addedby: String
}

type Institution @model @key(fields: ["id"]) {
  id: ID!
  name: String!
  type: String!
  district: String
  address: String!
  addressLine2: String
  city: String!
  state: String
  zip: String!
  phone: String
  website: String
  image: String
  isServiceProvider: Boolean
  serviceProviders: [ServiceProvider]
    @connection(keyName: "providersByPartner", fields: ["id"])
  staff: [Staff] @connection(keyName: "staffByInstitution", fields: ["id"])
  rooms: [Room] @connection(keyName: "roomByInstitution", fields: ["id"])
  curricula: [Curriculum] @connection(keyName: "curriculumByInstitution", fields: ["id"])
  classes: [Class] @connection(keyName: "classByInstitution", fields: ["id"])
  filters: [String]
  checkpoints: [commonCheckpoint] @connection(keyName: "byType", fields: ["id"])
  setupComplete: Boolean
}

type ServiceProvider
  @model(queries: null)
  @key(name: "providersByPartner", fields: ["partnerID", "providerID"]) {
  id: ID!
  partnerID: ID!
  providerID: ID!
  status: String
  providerInstitution: Institution @connection(fields: ["providerID"])
}

type Staff
  @model
  @key(name: "staffByInstitution", fields: ["institutionID", "staffEmail"]) {
  id: ID!
  institutionID: ID!
  staffAuthID: String!
  staffEmail: String!
  status: String
  statusChangeDate: AWSDate
  staffMember: Person @connection(fields: ["staffEmail", "staffAuthID"])
  institution: Institution @connection(fields: ["institutionID"])
}

type Room
  @model
  @key(name: "roomByInstitution", fields: ["institutionID"]) {
  id: ID!
  institutionID: ID!
  classID: ID
  teacherAuthID: String!
  teacherEmail: String!
  name: String!
  maxPersons: Int
  filters: [String]
  location: String
  startDate: AWSDate
  startTime: AWSTime
  endDate: AWSDate
  endTime: AWSTime
  length: Int
  repeat: String
  notes: String
  activeSyllabus: String
  frequency: String
  coTeachers: [RoomCoTeachers] @connection(keyName: "byRoom", fields: ["id"])
  institution: Institution @connection(fields: ["institutionID"])
  teacher: Person @connection(fields: ["teacherEmail", "teacherAuthID"])
  class: Class @connection(fields: ["classID"])
  curricula: [RoomCurriculum] @connection(keyName: "curriculumByRoom", fields: ["id"])
  activeLessonId: String
  ClosedPages: [String]
  disabledPages: [String]
  studentViewing: String
  displayData: [StudentSharing]
  currentPage: String
  completedLessons: [CompleteLesson]
  activeLessons: [String]
  classroomGroups: [ClassroomGroups]
    @connection(keyName: "groupsByClassroom", fields: ["id"])
  weekDay: String
  conferenceCallLink: String
  lessonImpactLog: [ImpactLogEntry]
}

type StudentSharing {
  studentAuthID: String
  lessonPageID: String
}

type ClassroomGroupStudents
  @model
  @key(name: "studentsByCRgroup", fields: ["classRoomGroupID"]) {
  id: ID!
  classRoomGroupID: ID!
  classRoomGroup: ClassroomGroups @connection(fields: ["classRoomGroupID"])
  studentEmail: String!
  studentAuthId: String!
  student: Person @connection(fields: ["studentEmail", "studentAuthId"])
  studentType: String
  studentNote: String
}

type ClassroomGroups @model @key(name: "groupsByClassroom", fields: ["classRoomID"]) {
  id: ID!
  classRoomID: ID!
  classRoom: Room @connection(fields: ["classRoomID"])
  groupName: String
  groupType: String
  advisorEmail: String!
  advisorAuthId: String!
  groupAdvisor: Person @connection(fields: ["advisorEmail", "advisorAuthId"])
  groupLocation: String
  classroomGroupsStudents: [ClassroomGroupStudents]
    @connection(keyName: "studentsByCRgroup", fields: ["id"])
}

type ImpactLogEntry {
  impactDate: AWSDate
  reasonComment: String
  lessonImpact: Float
  adjustment: String
}

type partnerGroups {
  partners: [String]
  advisors: [String]
}

type proficiencyGroups {
  groupName: String
  groupIDs: [String]
}

type CompleteLesson {
  lessonID: String
  time: AWSDateTime
}

type RoomCoTeachers @model @key(name: "byRoom", fields: ["roomID", "teacherID"]) {
  id: ID!
  roomID: ID!
  teacherID: ID!
  teacherEmail: String!
  teacherAuthID: String!
  room: Room @connection(fields: ["roomID"])
  teacher: Person @connection(fields: ["teacherEmail", "teacherAuthID"])
}

type Class @model @key(name: "classByInstitution", fields: ["institutionID"]) {
  id: ID!
  institutionID: ID!
  type: String
  name: String!
  roomId: ID!
  institution: Institution @connection(fields: ["institutionID"])
  room: Room @connection(fields: ["roomId"])
  students: [ClassStudent]! @connection(keyName: "byClass", fields: ["id"])
}

type ClassStudent
  @model
  @key(name: "byClass", fields: ["classID", "studentID"])
  @key(name: "classByStudent", fields: ["studentEmail"]) {
  id: ID!
  classID: ID!
  studentID: ID!
  studentEmail: String!
  studentAuthID: String!
  status: String
  group: String
  class: Class @connection(fields: ["classID"])
  student: Person @connection(fields: ["studentEmail", "studentAuthID"])
}

type Curriculum
  @model
  @key(fields: ["id"])
  @key(name: "curriculumByInstitution", fields: ["institutionID"]) {
  id: ID!
  institutionID: ID!
  name: String!
  type: String
  image: String
  summary: String
  description: String
  objectives: [String]
  languages: [Language]
  institution: Institution @connection(fields: ["institutionID"])
  designers: [String]
  syllabi: [Syllabus] @connection(keyName: "syllabusByCurriculum", fields: ["id"])
  universalSyllabusSeq: [String]
  checkpoints: [commonCheckpoint] @connection(keyName: "byType", fields: ["id"])
  universalSyllabus: [curriculumUnits] @connection(keyName: "unitsbyCurriculum", fields: ["id"])
}

type Topic
  @model
  @key(fields: ["id"])
  @key(name: "topicByCurriculum", fields: ["curriculumID"]) {
  id: ID!
  curriculumID: ID!
  learningObjectiveID: ID!
  curriculum: Curriculum @connection(fields: ["curriculumID"])
  learningObjective: LearningObjective @connection(fields: ["learningObjectiveID"])
  name: String!
  description: String
  distinguished: String
  excelled: String
  adequite: String
  basic: String
}

type CSequences @key(fields: ["id"]) @model {
  id: ID!
  sequence: [String]
}

type LearningObjective @model @key(fields: ["id"]) {
  id: ID!
  name: String!
  description: String
  curriculumID: ID!
}

type Rubric @model @key(fields: ["id"]) {
  id: ID!
  name: String
  criteria: String
  topicID: ID!
  topic: Topic @connection(fields: ["topicID"])
  curriculumID: ID!
}

type RoomCurriculum @model @key(name: "curriculumByRoom", fields: ["roomID"]) {
  id: ID!
  roomID: ID!
  curriculumID: ID!
  curriculum: Curriculum @connection(fields: ["curriculumID"])
}

type DataObject {
  name: String!
  data: String!
}

type AdditionalInputs {
  name: String
  input: String
}

type TruthGameInputs {
  id: String
  label: String
  isLie: Boolean
  text: String
}

type PollOption {
  id: String
  option: String
  isChoice: Boolean
}
type PollInputs {
  id: String
  question: String
  option: [PollOption]
}

type AdventureNodeOptions {
  id: String
  text: String
  nextText: String
}

type AdventureGameInputs {
  id: String
  text: String
  options: [AdventureNodeOptions]
}

type WarmUpData {
  story: [String]
  title: String
  additional: [AdditionalInputs]
  truthGame: [TruthGameInputs]
  poll: [PollInputs]
  adventureGame: [AdventureGameInputs]
}

type SelectedWord {
  id: Int
  text: String
}

type Selection {
  anchor: String
  color: String
  content: [SelectedWord]
  focus: String
  id: Int
}

type RawSelection {
  color: String
  selected: [String]
}

type CoreLessonData {
  selected: [Selection]
  rawSelected: [RawSelection]
  selectGroup: Int
}

type LineInput {
  example: String
  id: Int
  menuOpen: Boolean
  text: String
}

type ActivityData {
  editInput: String
  editMode: Boolean
  lines: [LineInput]
  title: String
}

type ComponentSummary {
  id: ID
  disabled: Boolean!
  open: Boolean!
  active: Boolean!
  stage: String!
  type: String!
  displayMode: String
}

type Quote {
  id: String
  source: String
  text: String!
}

type Link {
  id: String
  type: String
  text: String
  link: String
}

type AdditionalContent {
  video: String
  links: [Link]
}

type StudentInfo {
  id: String
  firstName: String
  preferredName: String
  lastName: String
}

type DisplayData {
  breakdownComponent: String
  studentInfo: StudentInfo
  warmUpData: WarmUpData
  corelessonData: CoreLessonData
  activityData: ActivityData
}

type Instructions {
  video: Boolean!
  link: String
  text: [String!]!
}

type Breakdown {
  included: Boolean!
  reflectionQuestions: [String]
}

type TruthGameInput {
  id: String
  label: String
}

type Inputs {
  title: Boolean!
  example: String
  titleExample: String
  textExample: String
  listInputNumber: Int
  truthGameInputs: [TruthGameInput]
  additionalInputs: [WritingPrompts!]
  pollInputs: [PollInputs]
  adventureGameInputs: [AdventureGameInputs]
}

type WritingPrompts {
  id: Int
  name: String!
  prompt: String!
  example: String!
}

type Content {
  video: Boolean!
  link: String
  title: String!
  artist: String!
  text: [String!]!
}

type Tool {
  id: String
  name: String!
  color: String!
  icon: String!
}

type Checkpoint @model {
  id: ID!
  label: String!
  title: String
  subtitle: String
  stage: String
  type: String!
  instructionsTitle: String
  instructions: String
  questions: [CheckpointQuestions]! @connection(keyName: "byCheckpoint", fields: ["id"])
  purpose: String
  objectives: String
  designers: [String]
  language: String
  estTime: Int
  scope: String
  questionSeq: [String]
}

type commonCheckpoint
  @model(queries: null)
  @key(name: "byType", fields: ["typeID", "checkpointID"]) {
  id: ID!
  type: String!
  typeID: ID!
  checkpointID: ID!
  institution: Institution @connection(fields: ["typeID"])
  curriculum: Curriculum @connection(fields: ["typeID"])
  checkpoint: Checkpoint @connection(fields: ["checkpointID"])
}

type CheckpointQuestions
  @model(queries: null)
  @key(name: "byCheckpoint", fields: ["checkpointID", "questionID"])
  @key(name: "byQuestion", fields: ["questionID", "checkpointID"]) {
  id: ID!
  checkpointID: ID!
  questionID: ID!
  required: Boolean!
  checkpoint: Checkpoint @connection(fields: ["checkpointID"])
  question: Question @connection(fields: ["questionID"])
}

type Option {
  text: String!
  label: String
  icon: String
  color: String
}

type Question @model {
  id: ID!
  label: String!
  type: String!
  question: String!
  designers: [String]
  language: String
  sourceId: String
  note: String
  options: [Option]
  published: Boolean
}

type QuestionSource @model {
  id: ID!
  name: String!
}

type QuestionType @model {
  id: ID!
  name: String!
}

type QuestionResponse {
  qid: String
  response: [String]
  otherResponse: String
}

type RoomMsgs
  @model
  @key(
    name: "byRoomID"
    fields: ["roomID", "createdAt"]
    queryField: "messagesByRoomID"
  ) {
  id: ID!
  roomID: ID!
  senderAuthID: String!
  senderEmail: String!
  body: String!
  createdAt: AWSDateTime
  sender: Person @connection(fields: ["senderEmail", "senderAuthID"])
}

type Lesson @model @key(fields: ["id"]) {
  id: ID!
  title: String!
  type: String!
  label: String
  instructions: [String]
  instructionsTitle: String
  theme: Theme
  grades: [Int]
  artistID: ID
  language: [Language!]
  SELStructure: String
  connection: String
  summary: String
  purpose: String
  designers: [String]
  objectives: [String]
  doFirstID: ID
  warmUpId: ID
  coreLessonId: ID
  activityId: ID
  filters: [String]
  coverImage: String
  summaryTitle: String
  introductionTitle: String
  introduction: String
  connectionTitle: String
  lessonPlan: [LessonComponents]
  measurements: [LessonRubrics]! @connection(keyName: "byLesson", fields: ["id"])
  institutionID: ID!
  institution: Institution @connection(fields: ["institutionID"])
  duration: Int
  resources: String
  notes: String
  targetAudience:String
}

type LessonRubrics @model @key(name: "byLesson", fields: ["lessonID", "rubricID"]) {
  id: ID!
  lessonID: ID!
  rubricID: ID!
  lesson: Lesson @connection(fields: ["lessonID"])
  rubric: Rubric @connection(fields: ["rubricID"])
}

type LessonComponents {
  type: String
  LessonComponentID: ID!
  sequence: Int
  stage: String
}

type Syllabus
  @model
  @key(fields: ["id"])
  @key(name: "syllabusByCurriculum", fields: ["curriculumID"]) {
  id: ID!
  name: String!
  type: String
  description: String
  methodology: String
  policies: String
  pupose: String
  objectives: String
  curriculumID: ID!
  languages: [Language]
  lessons: [SyllabusLesson] @connection(keyName: "lessonBySyllabus", fields: ["id"])
  designers: [String]
  status: Boolean
}

type SyllabusLesson
  @model
  @key(name: "lessonBySyllabus", fields: ["syllabusID", "lessonID"]) {
  id: ID!
  syllabusID: ID!
  lessonID: ID!
  unit: String
  sequence: Int
  status: String
  lesson: Lesson @connection(fields: ["lessonID"])
  complete: Boolean
  roster: [String!]
  viewing: String
  displayData: DisplayData
  lessonPlan: [ComponentSummary!]
  startDate: AWSDate
  endDate: AWSDate
  data: [StudentData] @connection(keyName: "bySyllabusLesson", fields: ["id"])
}

type StudentData
  @model(subscriptions: null)
  @key(fields: ["syllabusLessonID", "studentID"])
  @key(name: "bySyllabusLesson", fields: ["syllabusLessonID", "studentID"]) {
  id: ID!
  lessonProgress: String!
  currentLocation: String
  status: String!
  saveType: String
  syllabusLessonID: ID!
  syllabusLesson: SyllabusLesson @connection(fields: ["syllabusLessonID"])
  studentID: String!
  studentAuthID: String!
  student: Person! @connection(fields: ["studentID", "studentAuthID"])
  warmupData: WarmUpData
  corelessonData: CoreLessonData
  activityData: ActivityData
  doFirstData: [QuestionDataStudentData]!
    @connection(name: "byStudentData", fields: ["id"])
  checkpointData: [QuestionDataStudentData]!
    @connection(name: "byStudentData", fields: ["id"])
  anthologyContent: [AnthologyContent]
}

type AnthologyContent {
  type: String
  subType: String
  title: String
  subTitle: String
  description: String
  content: String
  classID: ID
  feedbacks: [String]
  edited: Boolean
}

type AnthologyComment @model {
  id: ID!
  text: String
  email: String!
  authID: String!
  person: Person @connection(fields: ["email", "authID"])
  attachments: [Attachment]
  edited: Boolean
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type Attachment {
  type: String
  url: String
  filename: String
  size: Int
}

type QuestionData @model {
  id: ID!
  syllabusLessonID: ID!
  checkpointID: ID!
  email: String!
  authID: String!
  person: Person @connection(fields: ["email", "authID"])
  componentType: String
  scheduleID: String
  lessonID: String
  responseObject: [QuestionResponse]
  syllabusLesson: SyllabusLesson @connection(fields: ["syllabusLessonID"])
}

type QuestionDataStudentData
  @model(queries: null)
  @key(name: "byStudentData", fields: ["studentDataID", "questionDataID"]) {
  id: ID!
  studentDataID: ID!
  studentData: StudentData @connection(fields: ["studentDataID"])
  questionDataID: ID!
  questionData: QuestionData @connection(fields: ["questionDataID"])
}

type Theme {
  type: String
  name: String!
  summary: [String!]!
  summaryLabel: String!
  quote: [Quote]
  connection: String
  images: [String!]!
  additionalContent: AdditionalContent
}

type PersonLocation
  @model
  @key(fields: ["personEmail", "personAuthID"])
  @key(
    name: "bySyllabusLesson"
    fields: ["syllabusLessonID"]
    queryField: "personLocationBySyllabusLesson"
  ) {
  id: ID!
  personAuthID: String!
  personEmail: String!
  syllabusLessonID: ID!
  lessonID: ID!
  roomID: ID!
  currentLocation: String
  lessonProgress: String
  person: Person @connection(fields: ["personEmail", "personAuthID"])
  syllabusLesson: SyllabusLesson @connection(fields: ["syllabusLessonID"])
  room: Room @connection(fields: ["roomID"])
}

type WidgetContent {
  text: String
  image: String
}

type Quotes {
  text: String
  author: String
}

type Links {
  text: String
  url: String
}

type NoticeboardWidget @model {
  id: ID!
  teacherAuthID: String!
  teacherEmail: String!
  roomID: String
  type: String
  placement: String
  title: String
  description: String
  content: WidgetContent
  quotes: [Quotes]
  links: [Links]
  active: Boolean
  teacher: Person @connection(fields: ["teacherEmail", "teacherAuthID"])
}

type Attendance
  @model
  @key(
    name: "byStudent"
    fields: ["studentID", "date"]
    queryField: "attendanceByStudent"
  ) {
  id: ID!
  studentID: ID!
  curriculumID: ID!
  syllabusID: ID!
  lessonID: ID!
  roomID: ID!
  date: AWSDate
  time: AWSTime
  isComplete: Boolean
  curriculum: Curriculum @connection(fields: ["curriculumID"])
  syllabus: UniversalSyllabus @connection(fields: ["syllabusID"])
  lesson: UniversalLesson @connection(fields: ["lessonID"])
  room: Room @connection(fields: ["roomID"])
}

type Planner @model {
  id: ID!
  type: String
  lessonID: ID
  lessonName: String
  syllabusID: ID
  roomID: ID
  description: String
  startDate: AWSDate
  endDate: AWSDate
  duration: Int
}

# Universal lesson tables ----------------------------------------------

type UniversalLesson @model @key(fields: ["id"]) {
  id: ID!
  type: String!
  label: String
  title: String!
  institutionID: ID!
  language: [Language!]
  designers: [String]
  objectives: [String]
  purpose: String
  introduction: String
  introductionTitle: String
  instructions: [String]
  instructionsTitle: String
  summary: String
  summaryTitle: String
  duration: Float
  resources: String
  notes: String
  cardImage: String
  cardCaption: String
  lessonPlan: [UniversalLessonPlan]
  homework: [UniversalLessonPlan]
  darkMode: Boolean
  rubrics: [String]
  smallGroup: String
  groupSize: Int
  groupType: String
  smallGroupSize: Int
  smallGroupOption: String
  studentMaterials: String
  targetAudience: String 
}

type UniversalLessonPlan {
  id: String
  title: String
  label: String
  description: String
  class: String
  active: Boolean
  disabled: Boolean
  displayMode: String
  open: Boolean
  estTime: String
  pageContent: [UniversalpageContent]
  activityType: String
  interactionType: [String]
  tags: [String]
}

type UniversalpageContent {
  id: String
  tags: [String]
  partType: String
  class: String
  partContent: [UniversalPartContent]
  showIfAsync:Boolean
}

type UniversalPartContent {
  id: String
  type: String
  class: String
  value: [UniversalContent]
  isRequired: Boolean
}

type UniversalContent {
  id: String
  type: String
  label: String
  value: String
  options: [UniversalContentOptions]
  caption: String
  height: String
  width: String
  class: String
  isRequired: Boolean
}

type UniversalContentOptions {
  id: String
  label: String
  text: String
}

type UniversalLessonStudentData
  @model
  @key(fields: ["id"])
  @key(name: "bySyllabusLessonAndStudent", fields: ["syllabusLessonID", "studentID"]) {
  id: ID!
  syllabusLessonID: ID!
  lessonID: ID!
  lessonPageID: ID!
  studentID: ID!
  studentAuthID: ID!
  studentEmail: String!
  roomID: String
  currentLocation: String
  lessonProgress: String
  pageData: [partInput]
  hasExerciseData: Boolean
  exerciseData: [ExerciseData]
}

type ExerciseData {
  id: String!
  entryData: [JournalEntryData]
  feedbacks: [String]
  shared: Boolean
}

type UniversalJournalData @model @key(fields: ["id"]) {
  id: ID!
  studentID: ID!
  studentAuthID: ID!
  studentEmail: String!
  type: String!
  entryData: [JournalEntryData]
  feedbacks: [String]
  shared: Boolean
  lessonID: ID
  syllabusLessonID: String
  lessonType: String
  roomID: String
}

type JournalEntryData {
  domID: String
  type: String
  input: String
}

type StudentPageInput {
  pagePartID: String
  pagePartInput: [partInput]
}

type partInput {
  domID: String
  options:[String]
  input: [String]
  comments: [InputComment]
}

type InputComment {
  commentBy: ID
  comment: String
}

type UniversalSyllabus
  @model
  @key(fields: ["id"]) {
  id: ID!
  name: String!
  type: String
  institutionID: ID!
  description: String
  methodology: String
  policies: String
  pupose: String
  objectives: String
  languages: [Language]
  lessons: [UniversalSyllabusLesson]
    @connection(keyName: "UniversalLessonsBySyllabus", fields: ["id"])
  universalLessonsSeq: [String]
  designers: [String]
  status: Boolean
}

type curriculumUnits @model @key(name: "unitsbyCurriculum", fields: ["curriculumId", "unitId"]) {
    id: ID!
    unitId: ID!
    unit: UniversalSyllabus @connection(fields: ["unitId"]) 
    curriculumId: ID!
}

# Need to add universalStudentData field
type UniversalSyllabusLesson
  @model
  @key(name: "UniversalLessonsBySyllabus", fields: ["syllabusID", "lessonID"]) {
  id: ID!
  syllabusID: ID!
  lessonID: ID!
  unit: String
  sequence: Int
  status: String
  complete: Boolean
  roster: [String!]
  viewing: String
  lesson: UniversalLesson @connection(fields: ["lessonID"])
  displayData: DisplayData
  lessonPlan: [ComponentSummary!]
  startDate: AWSDate
  endDate: AWSDate
  feedback: [UniversalLessonFeedback] @connection(fields: ["id"])
}

type UniversalLessonFeedback @model {
  id: ID!
  syllabusLessonID: ID!
  liked: String
  comment: String
  syllabusLesson: UniversalSyllabusLesson @connection(fields: ["syllabusLessonID"])
}

type StudentConnections @model {
  fromEmail: String!
  fromAuthID: String!
  toEmail: String!
  toAuthID: String!
  remarks: String
  fromStudent: Person @connection(fields: ["fromEmail", "fromAuthID"])
  toStudent: Person @connection(fields: ["toEmail", "toAuthID"])
}

type PersonSentiments @model @key(fields: ["personAuthID", "date"]) {
  personAuthID: String!
  personEmail: String!
  person: Person @connection(fields: ["personEmail", "personAuthID"])
  date: AWSDate!
  time: AWSTime!
  responseText: String
  backstory: String
}

type PersonFiles @model @key(fields: ["id"]) {
  id: ID!
  personAuthID: String!
  personEmail: String!
  uploadedAt: AWSDateTime
  feedbacks: [String]
  shared: Boolean
  lessonID: ID
  syllabusLessonID: String
  lessonType: String
  roomID: String
  files: [File]
  lessonPageID: ID
}

type File {
  fileName: String!
  fileKey: String!
  fileSize: Int
}

type Community @model @key(fields: ["id"]) {
  id: ID!
  cardName: String,
  cardDate: AWSDate,
  summary: String,
  cardImageLink: String,
  startTime: AWSDateTime,
  endTime: AWSDateTime,
  location: String,
  geoLocation: String
  additionalLinks: [String],
  additionalInfo: String,
  personAuthID: String!
  personEmail: String!
  person: Person @connection(fields: ["personEmail", "personAuthID"])
  chat: [CommunityChat] @connection(keyName: "chatByCommunity", fields: ["id"])
}

type CommunityChat @model 
@key(name: "chatByCommunity", fields: ["communityId"]) {
  id: ID!
  communityId: ID!
  personAuthID: String!
  personEmail: String!
  msg: String
  createdAt: AWSDateTime
}

type Subscription {
  onCreateUpdatePersonLocationItem(
    syllabusLessonID: ID!
    lessonID: ID!
    roomID: ID!
  ): PersonLocation
    @aws_subscribe(
      mutations: ["createPersonLocation", "updatePersonLocation", "deletePersonLocation"]
    )
  onDeletePersonLocationItem(
    syllabusLessonID: ID!
    lessonID: ID!
    roomID: ID!
  ): PersonLocation
    @aws_subscribe(
      mutations: ["deletePersonLocation"]
    )
  onChangeStudentData(syllabusLessonID: ID!): StudentData
    @aws_subscribe(mutations: ["createStudentData", "updateStudentData"])
  onChangeSyllabusLesson(id: ID!): SyllabusLesson
    @aws_subscribe(mutations: ["updateSyllabusLesson"])
  onChangeUniversalLessonStudentData(
    syllabusLessonID: ID!
    lessonID: ID!
    studentAuthID: ID!
  ): UniversalLessonStudentData
    @aws_subscribe(
      mutations: ["createUniversalLessonStudentData", "updateUniversalLessonStudentData"]
    )
  onChangeRoom(id: ID!): Room @aws_subscribe(mutations: ["updateRoom"])
}

input CreateClassStudentInput {
  id: ID
  classID: ID!
  studentID: ID!
  studentEmail: String!
  studentAuthID: String!
  status: String
  group: String
}

input CreateLessonRubricsInput {
  id: ID
  lessonID: ID!
  rubricID: ID!
}

input DeleteLessonRubricsInput {
  id: ID!
}

type Mutation {
  batchAddClassStudent(classStudents: [CreateClassStudentInput]): [ClassStudent]
  batchAddLessonRubrics(lessonRubrics: [CreateLessonRubricsInput]): [LessonRubrics]
  batchDeleteLessonRubrics(lessonRubrics: [DeleteLessonRubricsInput]): [LessonRubrics]
}

# Hello weorld
# hello
# hello
# hello